#!/bin/bash
set -euo pipefail

# Detect tool root from ilma location
ILMA_DIR="$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")"
TOOL_ROOT="$(dirname "$ILMA_DIR")"

# Store original arguments for commands that need special parsing
ORIGINAL_ARGS=("$@")

# Handle help and version - check for help early before any path resolution
HELP_REQUESTED=false
HELP_COMMAND=""

# Early scan for help flags and commands
for arg in "$@"; do
    if [[ "$arg" == "--help" || "$arg" == "-h" ]]; then
        HELP_REQUESTED=true
    elif [[ "$arg" =~ ^(backup|console|scan|prune|config|decrypt|extract|validate)$ ]]; then
        HELP_COMMAND="$arg"
    fi
done

# Handle main help (no subcommand specified)
if [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]] && [[ -z "$HELP_COMMAND" ]]; then
    cat <<EOF
Usage: ilma [COMMAND] [OPTIONS] [PROJECT_PATH]

COMMANDS:
  backup                               Create backup and context mirror (default)
  console                              Show project statistics
  scan                                 Scan project files and detect junk
  prune                                Dry-run analysis of files to clean (no deletion)
  config                               Show configuration details
  validate                             Validate configuration and connectivity
  decrypt                              Decrypt GPG-encrypted archive
  extract                              Safely extract archive (prevents tarbombs)

BACKUP OPTIONS:
  -b, --backup [OUTPUT_PATH]           Create backup directory (explicit)
  -a, --archive [OUTPUT_PATH]          Create compressed archive only
  -e, --encrypt [OUTPUT_PATH]          Create encrypted archive only  
  -c, --context [OUTPUT_PATH]          Create context mirror only
  -r, --remote SERVER:/PATH            Sync directly to remote server

SCAN/PRUNE OPTIONS:
  --type TYPE                          Use project type configuration
  --pretty                             Show detailed output
  --verbose                            Show detailed output
  --bak                                Create backup then delete junk files
  --delete                             Delete junk files without backup

DECRYPT/EXTRACT OPTIONS:
  --no-extract                         Decrypt only, do not extract archive
  --force                              Replace existing directories
  --target DIR                         Extract to specific directory

GLOBAL OPTIONS:
  -h, --help                           Show this help

PROJECT TYPES:
  bash, latex, node, python

EXAMPLES:
  ilma                                 Backup current directory
  ilma ~/my-project                    Backup specific project  
  ilma --type latex                    Backup, ignoring common LaTeX cruft
  ilma -a                              Create compressed archive only
  ilma -e                              Create encrypted archive only
  ilma -ar srv:/backup                 Archive and upload to remote server
  ilma -c ~/docs                       Create context mirror only
  ilma console                         Show project statistics
  ilma scan --type python --pretty     Scan Python project with detailed output
  ilma prune --type latex --verbose    Analyze LaTeX project cruft (dry-run only)
  ilma prune --type python --bak       Backup Python project then delete junk
  ilma prune --type latex --delete     Delete LaTeX project junk (no backup)
  ilma config                          Show effective configuration
  ilma decrypt file.tar.zst.gpg        Decrypt and extract GPG-encrypted archive
  ilma extract archive.tar.zst         Safely extract archive to contained directory

CONFIGURATION:
 ● Create .ilma.conf in project root to customize behavior.
 ● See example configurations: $ILMA_DIR/configs/.
 ● Consider adding .ilma.conf to ~/.config/git/ignore.
EOF
    exit 0
fi

# Handle subcommand help early
if [[ "$HELP_REQUESTED" == "true" && -n "$HELP_COMMAND" ]]; then
    case "$HELP_COMMAND" in
        scan)
            "$ILMA_DIR/commands/scan.sh" --help
            exit 0
            ;;
        prune)
            source "$ILMA_DIR/commands/prune.sh"
            usage
            exit 0
            ;;
        console)
            source "$ILMA_DIR/commands/console.sh"
            usage
            exit 0
            ;;
        config)
            source "$ILMA_DIR/commands/config.sh"
            usage
            exit 0
            ;;
        validate)
            "$ILMA_DIR/commands/validate.sh" --help
            exit 0
            ;;
        backup)
            "$ILMA_DIR/commands/backup.sh" --help
            exit 0
            ;;
        extract)
            cat <<EOF
Usage: ilma extract [OPTIONS] <archive_file>

Safely extract archive to contained directory (prevents tarbombs).

Creates a directory based on the archive name and extracts contents there.
Supports all compression formats: .tar.zst, .tar.gz, .tar.bz2, .tar.xz, etc.

OPTIONS:
  --force            Replace existing target directory if it exists
  --target DIR       Extract to specific directory instead of auto-generated name

Examples:
  ilma extract project.tar.zst             # Extracts to project/
  ilma extract backup.tar.gz               # Extracts to backup/
  ilma extract --force project.tar.zst     # Replace existing project/ directory
  ilma extract --target temp backup.tar.gz # Extract to temp/ directory
EOF
            exit 0
            ;;
        decrypt)
            cat <<EOF
Usage: ilma decrypt [OPTIONS] <encrypted_file>

Decrypt a GPG-encrypted file and optionally extract if it's an archive.

OPTIONS:
  --no-extract       Decrypt only, do not extract archive
  --force            Replace existing target directory if it exists
  --target DIR       Extract to specific directory instead of auto-generated name

Examples:
  ilma decrypt backup.tar.zst.gpg              # Decrypt and extract to backup/
  ilma decrypt project.tar.gz.gpg             # Decrypt and extract to project/
  ilma decrypt --no-extract data.tar.gpg      # Decrypt to data.tar only
  ilma decrypt --force backup.tar.zst.gpg     # Replace existing backup/ directory
  ilma decrypt --target restored backup.gpg   # Extract to restored/ directory
EOF
            exit 0
            ;;
    esac
fi

# Parse arguments to determine command and options
COMMAND=""
TYPE=""
BACKUP_FLAG=""
ARCHIVE_FLAG=""
ENCRYPT_FLAG=""
CONTEXT_FLAG=""
REMOTE_FLAG=""
CONFIG_FLAG=""
PROJECT_ROOT=""
VERBOSE_FLAG=""
PRETTY_FLAG=""
BAK_FLAG=""
DELETE_FLAG=""
NO_EXTRACT_FLAG=""
FORCE_FLAG=""
OUTDIR_FLAG=""

# First pass - scan all arguments to identify command
COMMAND="backup"  # Default command
for arg in "$@"; do
    case "$arg" in
        backup|console|scan|prune|config|decrypt|extract|validate)
            COMMAND="$arg"
            break
            ;;
        --config)
            COMMAND="config"
            break
            ;;
    esac
done

# Expand combined short flags (e.g., -abc becomes -a -b -c)
# Special handling: -r requires an argument, so combinations with -r are not supported
expand_combined_flags() {
    local expanded_args=()
    for arg in "$@"; do
        if [[ "$arg" =~ ^-[abce]{2,}$ ]]; then
            # This is a combined short flag WITHOUT -r (which requires an argument)
            flag_chars="${arg#-}"
            for ((i=0; i<${#flag_chars}; i++)); do
                expanded_args+=("-${flag_chars:i:1}")
            done
        elif [[ "$arg" =~ ^-[abcer]{2,}$ ]] && [[ "$arg" =~ r ]]; then
            # Combined flag containing -r: not supported due to argument complexity
            echo "Error: Combined flags with -r are not supported. Use -r separately: -r SERVER:/PATH" >&2
            return 1
        else
            expanded_args+=("$arg")
        fi
    done
    echo "${expanded_args[@]}"
}

# Second pass - parse remaining arguments
# Skip parsing entirely if command is validate (let validate.sh handle its own args)
if [[ "$COMMAND" == "validate" ]]; then
    # Skip all arguments - validate.sh will handle them
    while (( $# > 0 )); do
        shift
    done
else
    # Expand combined short flags (-abc becomes -a -b -c, but -r combinations not supported)
    # Also expand single short flags like -e to --encrypt
    if [[ "$COMMAND" == "backup" ]]; then
        expanded_args=()
        for arg in "$@"; do
            case "$arg" in
                -a) expanded_args+=(--archive) ;;
                -b) expanded_args+=(--backup) ;;
                -c) expanded_args+=(--context) ;;
                -e) expanded_args+=(--encrypt) ;;
                -r) expanded_args+=(--remote) ;;
                -*) 
                    # Handle combined flags
                    if [[ "$arg" =~ ^-[abce]{2,}$ ]]; then
                        flag_chars="${arg#-}"
                        for ((i=0; i<${#flag_chars}; i++)); do
                            case "${flag_chars:i:1}" in
                                a) expanded_args+=(--archive) ;;
                                b) expanded_args+=(--backup) ;;
                                c) expanded_args+=(--context) ;;
                                e) expanded_args+=(--encrypt) ;;
                            esac
                        done
                    else
                        expanded_args+=("$arg")
                    fi
                    ;;
                *) expanded_args+=("$arg") ;;
            esac
        done
        set -- "${expanded_args[@]}"
    fi
    while (( $# > 0 )); do
        case "$1" in
            backup|console|scan|prune|config|decrypt|extract|validate)
                # Skip command names (already detected in first pass)
                shift
                ;;
            --backup|-b)
            BACKUP_FLAG="true"
            # Check if next argument is explicitly an output path (directory path with .bak extension)
            if [[ -n "${2:-}" && "${2:0:1}" != "-" && "${2}" =~ \.bak$ ]]; then
                BACKUP_FLAG="$2"
                shift 2
            else
                shift
            fi
            ;;
        --archive|-a)
            ARCHIVE_FLAG="true"
            # Check if next argument is explicitly an output path (ends with archive extension)
            if [[ -n "${2:-}" && "${2:0:1}" != "-" && "${2}" =~ \.(tar\.|tgz|tbz2|txz).*$ ]]; then
                ARCHIVE_FLAG="$2"
                shift 2
            else
                shift
            fi
            ;;
        --encrypt|-e)
            ENCRYPT_FLAG="true"
            # Check if next argument is explicitly an output path (must end with .gpg to be output)
            if [[ -n "${2:-}" && "${2:0:1}" != "-" && "${2}" =~ \.gpg$ ]]; then
                ENCRYPT_FLAG="$2"
                shift 2
            else
                shift
            fi
            ;;
        --context|-c)
            CONTEXT_FLAG="true"
            # Check if next argument is explicitly an output path (has extension or is absolute path)
            if [[ -n "${2:-}" && "${2:0:1}" != "-" && ( "${2}" =~ \.[a-z]+$ || "${2:0:1}" == "/" ) ]]; then
                CONTEXT_FLAG="$2"
                shift 2
            else
                shift
            fi
            ;;
        --remote|-r)
            if [[ -z "${2:-}" ]]; then
                echo "Error: --remote requires SERVER:/PATH argument" >&2
                exit 1
            fi
            REMOTE_FLAG="$2"
            shift 2
            ;;
        --config)
            CONFIG_FLAG="true"
            shift
            ;;
        --type)
            if [[ -z "${2:-}" ]]; then
                echo "Error: --type requires an argument" >&2
                exit 1
            fi
            TYPE="$2"
            shift 2
            ;;
        --verbose)
            VERBOSE_FLAG="true"
            shift
            ;;
        --pretty)
            PRETTY_FLAG="true"
            shift
            ;;
        --bak)
            BAK_FLAG="true"
            shift
            ;;
        --delete)
            DELETE_FLAG="true"
            shift
            ;;
        --no-extract)
            NO_EXTRACT_FLAG="true"
            shift
            ;;
        --force)
            FORCE_FLAG="true"
            shift
            ;;
        --target)
            if [[ -z "${2:-}" ]]; then
                echo "Error: --target requires a directory path" >&2
                exit 1
            fi
            OUTDIR_FLAG="$2"
            shift 2
            ;;
        backup|console|scan|prune|config|decrypt|extract)
            # Skip command names
            shift
            ;;
        --help|-h)
            # Skip help flags (handled earlier)
            shift
            ;;
        *)
            # Collect all remaining arguments as potential project paths
            if [[ -z "$PROJECT_ROOT" ]]; then
                PROJECT_ROOT="$(realpath "$1" 2>/dev/null)" || { echo "Error: Invalid path '$1'"; exit 1; }
                ADDITIONAL_PATHS=()
                shift
                while [[ $# -gt 0 && "$1" != --* ]]; do
                    resolved_path="$(realpath "$1" 2>/dev/null)" || { echo "Error: Invalid path '$1'"; exit 1; }
                    ADDITIONAL_PATHS+=("$resolved_path")
                    shift
                done
            else
                shift
            fi
            ;;
    esac
    done
fi

# Set default project root if not specified
if [[ -z "$PROJECT_ROOT" ]]; then
    PROJECT_ROOT="$(pwd)"
fi

# Detect if PROJECT_ROOT is a file or directory
IS_SINGLE_FILE=false
if [[ "$COMMAND" != "decrypt" && "$COMMAND" != "extract" && "$COMMAND" != "validate" ]]; then
    if [[ -f "$PROJECT_ROOT" ]]; then
        IS_SINGLE_FILE=true
        SINGLE_FILE_PATH="$PROJECT_ROOT"
        PROJECT_ROOT="$(dirname "$PROJECT_ROOT")"
        echo "Single file mode: $(basename "$SINGLE_FILE_PATH")"
    elif [[ ! -d "$PROJECT_ROOT" ]]; then
        echo "Error: Directory or file does not exist: $PROJECT_ROOT"
        exit 1
    fi
fi

PROJECT_NAME="$(basename "$PROJECT_ROOT")"

# Load configuration and compression library
source "$ILMA_DIR/commands/config.sh"
source "$ILMA_DIR/lib/deps/compression.sh"
load_config "$PROJECT_ROOT" "$TYPE"

# Handle --config command early (before special modes)
if [[ "$CONFIG_FLAG" == "true" || "$COMMAND" == "config" ]]; then
    show_config "$PROJECT_ROOT"
    exit 0
fi

# Dispatch to appropriate command
case "$COMMAND" in
    backup)
        # Load config for all backup modes
        source "$ILMA_DIR/commands/config.sh"
        load_config "$PROJECT_ROOT" "$TYPE"
        
        # Handle single file operations first
        if [[ "$IS_SINGLE_FILE" == "true" ]]; then
            source "$ILMA_DIR/lib/singles.sh"
            
            # Single file encryption: ilma -e file.txt -> file.txt.gpg
            if [[ "$ENCRYPT_FLAG" == "true" || -n "$ENCRYPT_FLAG" ]]; then
                if [[ -z "$GPG_KEY_ID" ]]; then
                    echo "Error: GPG key not configured. Set GPG_KEY_ID in config."
                    exit 1
                fi
                do_single_file_encryption "$SINGLE_FILE_PATH"
                exit 0
            fi
            
            # Default single file backup: ilma file.txt -> file.txt.bak
            do_single_file_backup "$SINGLE_FILE_PATH"
            exit 0
        fi
        
        # Handle multiple backup operations (no longer mutually exclusive)
        OPERATIONS_PERFORMED=false
        
        # Standard backup operation
        if [[ "$BACKUP_FLAG" == "true" || -n "$BACKUP_FLAG" ]]; then
            source "$ILMA_DIR/commands/backup.sh"
            # Override base directories with --target if specified
            if [[ -n "$OUTDIR_FLAG" ]]; then
                original_backup_base_dir="$BACKUP_BASE_DIR"
                original_context_base_dir="$CONTEXT_BASE_DIR"
                BACKUP_BASE_DIR="$OUTDIR_FLAG"
                CONTEXT_BASE_DIR="$OUTDIR_FLAG"
                do_backup "$PROJECT_ROOT"
                BACKUP_BASE_DIR="$original_backup_base_dir"
                CONTEXT_BASE_DIR="$original_context_base_dir"
            else
                do_backup "$PROJECT_ROOT"
            fi
            OPERATIONS_PERFORMED=true
        fi
        
        # Archive operation
        if [[ "$ARCHIVE_FLAG" == "true" || -n "$ARCHIVE_FLAG" ]]; then
            source "$ILMA_DIR/lib/backup/archive.sh"
            output_path="$([[ "$ARCHIVE_FLAG" == "true" ]] && echo "" || echo "$ARCHIVE_FLAG")"
            # Override with --target if specified
            if [[ -n "$OUTDIR_FLAG" && -z "$output_path" ]]; then
                project_name="$(basename "$PROJECT_ROOT")"
                output_path="$OUTDIR_FLAG/${project_name}$(get_archive_extension "$COMPRESSION_TYPE")"
            fi
            create_archive_only "$PROJECT_ROOT" "$output_path"
            OPERATIONS_PERFORMED=true
            
            # Handle remote upload for archive if specified
            if [[ -n "$REMOTE_FLAG" ]]; then
                source "$ILMA_DIR/lib/backup/remote.sh"
                archive_file="$output_path"
                [[ -z "$archive_file" ]] && archive_file="$(dirname "$PROJECT_ROOT")/$(basename "$PROJECT_ROOT")$(get_archive_extension "$COMPRESSION_TYPE")"
                sync_archive_to_remote "$archive_file" "$REMOTE_FLAG"
            fi
        fi
        
        # Encrypt operation (creates encrypted archive)
        if [[ "$ENCRYPT_FLAG" == "true" || -n "$ENCRYPT_FLAG" ]]; then
            source "$ILMA_DIR/lib/backup/encrypt.sh"
            output_path="$([[ "$ENCRYPT_FLAG" == "true" ]] && echo "" || echo "$ENCRYPT_FLAG")"
            # Override with --target if specified
            if [[ -n "$OUTDIR_FLAG" && -z "$output_path" ]]; then
                project_name="$(basename "$PROJECT_ROOT")"
                output_path="$OUTDIR_FLAG/${project_name}$(get_archive_extension "$COMPRESSION_TYPE")${GPG_OUTPUT_EXTENSION:-.gpg}"
            fi
            create_encrypted_archive "$PROJECT_ROOT" "$output_path"
            OPERATIONS_PERFORMED=true
            
            # Handle remote upload for encrypted file if specified
            if [[ -n "$REMOTE_FLAG" ]]; then
                source "$ILMA_DIR/lib/backup/remote.sh"
                encrypted_file="$output_path"
                [[ -z "$encrypted_file" ]] && encrypted_file="$(dirname "$PROJECT_ROOT")/$(basename "$PROJECT_ROOT")$(get_archive_extension "$COMPRESSION_TYPE").gpg"
                sync_archive_to_remote "$encrypted_file" "$REMOTE_FLAG"
            fi
        fi
        
        # Context operation
        if [[ "$CONTEXT_FLAG" == "true" || -n "$CONTEXT_FLAG" ]]; then
            source "$ILMA_DIR/lib/backup/context.sh"
            output_path="$([[ "$CONTEXT_FLAG" == "true" ]] && echo "" || echo "$CONTEXT_FLAG")"
            # Override with --target if specified
            if [[ -n "$OUTDIR_FLAG" && -z "$output_path" ]]; then
                project_name="$(basename "$PROJECT_ROOT")"
                output_path="$OUTDIR_FLAG/${project_name}.context"
            fi
            create_context_only "$PROJECT_ROOT" "$output_path"
            OPERATIONS_PERFORMED=true
        fi
        
        # Remote sync operation (for non-archive files)
        if [[ -n "$REMOTE_FLAG" && "$ARCHIVE_FLAG" != "true" && -z "$ARCHIVE_FLAG" && "$ENCRYPT_FLAG" != "true" && -z "$ENCRYPT_FLAG" ]]; then
            source "$ILMA_DIR/lib/backup/remote.sh"
            sync_to_remote "$PROJECT_ROOT" "$REMOTE_FLAG"
            OPERATIONS_PERFORMED=true
        fi
        
        # Default backup if no operations specified
        if [[ "$OPERATIONS_PERFORMED" == "false" ]]; then
            source "$ILMA_DIR/commands/backup.sh"
            do_backup "$PROJECT_ROOT"
            
            # Show stats after backup completion
            if [[ "$CONFIG_FOUND" == "true" ]]; then
                # Set mirror directory path for stats
                if [[ -n "$CONTEXT_BASE_DIR" ]]; then
                    MIRROR_DIR="$CONTEXT_BASE_DIR/$PROJECT_NAME"
                else
                    MAIN_BACKUP_DIR="$BACKUP_BASE_DIR/${PROJECT_NAME}.bak"
                    MIRROR_DIR="$MAIN_BACKUP_DIR/$PROJECT_NAME"
                fi

                source "$ILMA_DIR/commands/console.sh"
                show_backup_stats "$PROJECT_ROOT" "$MIRROR_DIR"
            fi
        fi
        ;;
    console)
        source "$ILMA_DIR/commands/console.sh"
        show_console_summary "$PROJECT_ROOT"
        ;;
    scan)
        # Load config without special mode handling for scan
        source "$ILMA_DIR/commands/config.sh"
        load_config "$PROJECT_ROOT" "$TYPE"

        # Build arguments for scan.sh
        scan_args=()
        [[ -n "$TYPE" ]] && scan_args+=(--type "$TYPE")
        [[ "$PRETTY_FLAG" == "true" ]] && scan_args+=(--pretty)
        scan_args+=("$PROJECT_ROOT")

        # Call scan.sh directly
        "$ILMA_DIR/commands/scan.sh" "${scan_args[@]}"
        ;;
    prune)
        # Load config
        source "$ILMA_DIR/commands/config.sh"
        load_config "$PROJECT_ROOT" "$TYPE"
        # Only call handle_special_modes if backup is needed (for --bak flag)
        if [[ "$BAK_FLAG" == "true" ]]; then
            handle_special_modes "" "$PROJECT_ROOT"
        fi
        source "$ILMA_DIR/commands/prune.sh"

        # Determine if we're in delete mode
        delete_mode="false"
        if [[ "$BAK_FLAG" == "true" || "$DELETE_FLAG" == "true" ]]; then
            delete_mode="true"
        fi

        # If --bak flag is set, create complete backup first
        if [[ "$BAK_FLAG" == "true" ]]; then
            echo "Creating complete backup before deletion..."
            PROJECT_NAME="$(basename "$PROJECT_ROOT")"
            PARENT_DIR="$(dirname "$PROJECT_ROOT")"
            TIMESTAMP="$(date '+%Y%m%d-%H%M%S')"
            # Get archive extension based on compression type
            ARCHIVE_EXT=$(get_archive_extension "$COMPRESSION_TYPE")
            BACKUP_ARCHIVE="$PARENT_DIR/${PROJECT_NAME}.orig${ARCHIVE_EXT}"

            # Get tar option for compression
            TAR_OPTION=$(get_tar_option "$COMPRESSION_TYPE")
            if [[ -n "$TAR_OPTION" ]]; then
                TAR_CMD="tar $TAR_OPTION -cf"
            else
                TAR_CMD="tar -cf"
            fi

            if $TAR_CMD "$BACKUP_ARCHIVE" -C "$PROJECT_ROOT" .; then
                echo "Complete backup created: $BACKUP_ARCHIVE"
            else
                echo "ERROR: Failed to create backup archive"
                exit 1
            fi
            echo
            echo "Backup complete. Now proceeding with junk file deletion..."
            echo
        fi

        # Run prune analysis (and deletion if requested)
        do_prune "$PROJECT_ROOT" "${VERBOSE_FLAG:-false}" "$TYPE" "$delete_mode"

        # Show stats after backup completion if backup was created
        if [[ "$BAK_FLAG" == "true" && "$CONFIG_FOUND" == "true" ]]; then
            echo
            if [[ -n "$CONTEXT_BASE_DIR" ]]; then
                MIRROR_DIR="$CONTEXT_BASE_DIR/$PROJECT_NAME"
            else
                MAIN_BACKUP_DIR="$BACKUP_BASE_DIR/${PROJECT_NAME}.bak"
                MIRROR_DIR="$MAIN_BACKUP_DIR/$PROJECT_NAME"
            fi

            source "$ILMA_DIR/commands/console.sh"
            show_backup_stats "$PROJECT_ROOT" "$MIRROR_DIR"
        fi
        ;;
    config)
        show_config "$PROJECT_ROOT"
        ;;
    validate)
        # Extract args after 'validate' command and pass them directly to validate.sh
        validate_args=()
        validate_found=false
        for ((i=0; i<${#ORIGINAL_ARGS[@]}; i++)); do
            if [[ "${ORIGINAL_ARGS[i]}" == "validate" ]]; then
                validate_found=true
                continue
            fi
            if [[ "$validate_found" == "true" ]]; then
                validate_args+=("${ORIGINAL_ARGS[i]}")
            fi
        done
        
        # Call validate.sh directly with all original arguments
        "$ILMA_DIR/commands/validate.sh" "${validate_args[@]}"
        ;;
    decrypt)
        source "$ILMA_DIR/commands/decrypt.sh"
        do_decrypt "$PROJECT_ROOT" "$NO_EXTRACT_FLAG" "$FORCE_FLAG" "$OUTDIR_FLAG"
        ;;
    extract)
        source "$ILMA_DIR/commands/decrypt.sh"
        do_extract "$PROJECT_ROOT" "$FORCE_FLAG" "$OUTDIR_FLAG"
        ;;
    *)
        echo "Error: Unknown command '$COMMAND'"
        exit 1
        ;;
esac

exit 0
