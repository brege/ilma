#!/bin/bash
set -euo pipefail

# Detect tool root from ilma location
ILMA_DIR="$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")"
TOOL_ROOT="$(dirname "$ILMA_DIR")"

# Store original arguments for commands that need special parsing
ORIGINAL_ARGS=("$@")

# Handle help and version - check for help early before any path resolution
HELP_REQUESTED=false
HELP_COMMAND=""

# Early scan for help flags and commands
for arg in "$@"; do
    if [[ "$arg" == "--help" || "$arg" == "-h" ]]; then
        HELP_REQUESTED=true
    elif [[ "$arg" =~ ^(backup|console|scan|prune|config|decrypt|extract|validate)$ ]]; then
        HELP_COMMAND="$arg"
    fi
done

# Handle main help (no subcommand specified)
if [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]] && [[ -z "$HELP_COMMAND" ]]; then
    cat <<EOF
Usage: ilma [COMMAND] [OPTIONS] [PROJECT_PATH]

COMMANDS:
  backup                               Create backup and context mirror (default)
  console                              Show project statistics
  scan                                 Scan project files and detect junk
  prune                                Dry-run analysis of files to clean (no deletion)
  config                               Show configuration details
  validate                             Validate configuration and connectivity
  decrypt                              Decrypt GPG-encrypted archive
  extract                              Safely extract archive (prevents tarbombs)

OPTIONS:
  --archive PROJECT_PATH ARCHIVE_PATH  Create archive at specific location
  --type TYPE                          Use project type configuration
  --pretty                             Show detailed output (for scan command)
  --verbose                            Show detailed output (for prune command)
  --bak                                Create backup then delete junk files (for prune command)
  --delete                             Delete junk files without backup (for prune command)
  -h, --help                           Show this help

PROJECT TYPES:
  default, minimal, bash, latex, node, python

EXAMPLES:
  ilma                                 Backup current directory
  ilma ~/my-project                    Backup specific project
  ilma --type latex                    Backup, ignoring common LaTeX cruft
  ilma --archive project archive/      Archive project to a specific directory
  ilma console                         Show project statistics
  ilma scan --type python --pretty     Scan Python project with detailed output
  ilma prune --type latex --verbose    Analyze LaTeX project cruft (dry-run only)
  ilma prune --type python --bak       Backup Python project then delete junk
  ilma prune --type latex --delete     Delete LaTeX project junk (no backup)
  ilma config                          Show effective configuration
  ilma decrypt file.tar.zst.gpg        Decrypt and extract GPG-encrypted archive
  ilma extract archive.tar.zst         Safely extract archive to contained directory

CONFIGURATION:
 ● Create .ilma.conf in project root to customize behavior.
 ● See example configurations: $ILMA_DIR/configs/.
 ● Consider adding .ilma.conf to ~/.config/git/ignore.
EOF
    exit 0
fi

# Handle subcommand help early
if [[ "$HELP_REQUESTED" == "true" && -n "$HELP_COMMAND" ]]; then
    case "$HELP_COMMAND" in
        scan)
            "$ILMA_DIR/lib/scan.sh" --help
            exit 0
            ;;
        prune)
            source "$ILMA_DIR/lib/prune.sh"
            usage
            exit 0
            ;;
        console)
            source "$ILMA_DIR/lib/console.sh"
            usage
            exit 0
            ;;
        config)
            source "$ILMA_DIR/lib/config.sh"
            usage
            exit 0
            ;;
        validate)
            cat <<EOF
Usage: ilma validate [LEVEL] [PROJECT_PATH]

Validate configuration and connectivity for ilma setup.

LEVELS:
  basic       Basic configuration and path validation (default)
  full        Include remote connectivity tests  
  smoke-test  Full validation plus end-to-end test with generated dummy project

Examples:
  ilma validate                         # Basic validation of current directory
  ilma validate full /path/to/project   # Full validation of specific project  
  ilma validate smoke-test              # Complete test using temporary dummy project

Note: smoke-test creates its own temporary test project for validation.

Exit codes:
  0 - All checks passed (warnings allowed)
  1 - Validation failed with errors
EOF
            exit 0
            ;;
        backup)
            cat <<EOF
Usage: ilma backup [OPTIONS] [PROJECT_PATH]

Create backup and context mirror of a project (default command).

This is the same as running 'ilma' without any command.
For full help, run: ilma --help
EOF
            exit 0
            ;;
        extract)
            cat <<EOF
Usage: ilma extract <archive_file>

Safely extract archive to contained directory (prevents tarbombs).

Creates a directory based on the archive name and extracts contents there.
Supports all compression formats: .tar.zst, .tar.gz, .tar.bz2, .tar.xz, etc.

Examples:
  ilma extract project.tar.zst     # Extracts to project/
  ilma extract backup.tar.gz       # Extracts to backup/
EOF
            exit 0
            ;;
    esac
fi

# Parse arguments to determine command and options
COMMAND=""
TYPE=""
ARCHIVE_FLAG=""
CONFIG_FLAG=""
PROJECT_ROOT=""
VERBOSE_FLAG=""
PRETTY_FLAG=""
BAK_FLAG=""
DELETE_FLAG=""

# First pass - scan all arguments to identify command
COMMAND="backup"  # Default command
for arg in "$@"; do
    case "$arg" in
        backup|console|scan|prune|config|decrypt|extract|validate)
            COMMAND="$arg"
            break
            ;;
        --config)
            COMMAND="config"
            break
            ;;
    esac
done

# Second pass - parse remaining arguments
while (( $# > 0 )); do
    case "$1" in
        backup|console|scan|prune|config|decrypt|extract|validate)
            # Skip command names (already detected in first pass)
            shift
            ;;
        --archive)
            if [[ -n "${2:-}" && -n "${3:-}" ]]; then
                PROJECT_ROOT="$(realpath "$2" 2>/dev/null)" || { echo "Error: Invalid project path '$2'"; exit 1; }
                ARCHIVE_FLAG="$3"
                shift 3
            else
                echo "Error: --archive requires PROJECT_PATH and ARCHIVE_PATH"
                exit 1
            fi
            ;;
        --config)
            CONFIG_FLAG="true"
            shift
            ;;
        --type)
            if [[ -z "${2:-}" ]]; then
                echo "Error: --type requires an argument" >&2
                exit 1
            fi
            TYPE="$2"
            shift 2
            ;;
        --verbose)
            VERBOSE_FLAG="true"
            shift
            ;;
        --pretty)
            PRETTY_FLAG="true"
            shift
            ;;
        --bak)
            BAK_FLAG="true"
            shift
            ;;
        --delete)
            DELETE_FLAG="true"
            shift
            ;;
        backup|console|scan|prune|config|decrypt|extract)
            # Skip command names
            shift
            ;;
        --help|-h)
            # Skip help flags (handled earlier)
            shift
            ;;
        *)
            if [[ -z "$PROJECT_ROOT" ]]; then
                PROJECT_ROOT="$(realpath "$1" 2>/dev/null)" || { echo "Error: Invalid path '$1'"; exit 1; }
            fi
            shift
            ;;
    esac
done

# Set default project root if not specified
if [[ -z "$PROJECT_ROOT" ]]; then
    PROJECT_ROOT="$(pwd)"
fi

# Validate project directory (except for decrypt/extract/validate commands which handle their own validation)
if [[ "$COMMAND" != "decrypt" && "$COMMAND" != "extract" && "$COMMAND" != "validate" ]]; then
    if [[ ! -d "$PROJECT_ROOT" ]]; then
        echo "Error: Directory does not exist: $PROJECT_ROOT"
        exit 1
    fi
fi

PROJECT_NAME="$(basename "$PROJECT_ROOT")"

# Load configuration and compression library
source "$ILMA_DIR/lib/config.sh"
source "$ILMA_DIR/lib/compression.sh"
load_config "$PROJECT_ROOT" "$TYPE"

# Handle --config command early (before special modes)
if [[ "$CONFIG_FLAG" == "true" || "$COMMAND" == "config" ]]; then
    show_config "$PROJECT_ROOT"
    exit 0
fi

handle_special_modes "$ARCHIVE_FLAG" "$PROJECT_ROOT"

# Dispatch to appropriate command
case "$COMMAND" in
    backup)
        source "$ILMA_DIR/lib/backup.sh"
        do_backup "$PROJECT_ROOT"
        create_archive "$PROJECT_ROOT" "$ARCHIVE_FLAG"

        # Show stats after backup completion
        if [[ "$CONFIG_FOUND" == "true" ]]; then
            # Set mirror directory path for stats
            if [[ -n "$CONTEXT_BASE_DIR" ]]; then
                MIRROR_DIR="$CONTEXT_BASE_DIR/$PROJECT_NAME"
            else
                MAIN_BACKUP_DIR="$BACKUP_BASE_DIR/${PROJECT_NAME}.bak"
                MIRROR_DIR="$MAIN_BACKUP_DIR/$PROJECT_NAME"
            fi

            source "$ILMA_DIR/lib/console.sh"
            show_backup_stats "$PROJECT_ROOT" "$MIRROR_DIR"
        fi
        ;;
    console)
        source "$ILMA_DIR/lib/console.sh"
        show_console_summary "$PROJECT_ROOT"
        ;;
    scan)
        # Load config without special mode handling for scan
        source "$ILMA_DIR/lib/config.sh"
        load_config "$PROJECT_ROOT" "$TYPE"

        # Build arguments for scan.sh
        scan_args=()
        [[ -n "$TYPE" ]] && scan_args+=(--type "$TYPE")
        [[ "$PRETTY_FLAG" == "true" ]] && scan_args+=(--pretty)
        scan_args+=("$PROJECT_ROOT")

        # Call scan.sh directly
        "$ILMA_DIR/lib/scan.sh" "${scan_args[@]}"
        ;;
    prune)
        # Load config
        source "$ILMA_DIR/lib/config.sh"
        load_config "$PROJECT_ROOT" "$TYPE"
        # Only call handle_special_modes if backup is needed (for --bak flag)
        if [[ "$BAK_FLAG" == "true" ]]; then
            handle_special_modes "" "$PROJECT_ROOT"
        fi
        source "$ILMA_DIR/lib/prune.sh"

        # Determine if we're in delete mode
        delete_mode="false"
        if [[ "$BAK_FLAG" == "true" || "$DELETE_FLAG" == "true" ]]; then
            delete_mode="true"
        fi

        # If --bak flag is set, create complete backup first
        if [[ "$BAK_FLAG" == "true" ]]; then
            echo "Creating complete backup before deletion..."
            PROJECT_NAME="$(basename "$PROJECT_ROOT")"
            PARENT_DIR="$(dirname "$PROJECT_ROOT")"
            TIMESTAMP="$(date '+%Y%m%d-%H%M%S')"
            # Get archive extension based on compression type
            ARCHIVE_EXT=$(get_archive_extension "$COMPRESSION_TYPE")
            BACKUP_ARCHIVE="$PARENT_DIR/${PROJECT_NAME}.orig${ARCHIVE_EXT}"

            # Get tar option for compression
            TAR_OPTION=$(get_tar_option "$COMPRESSION_TYPE")
            if [[ -n "$TAR_OPTION" ]]; then
                TAR_CMD="tar $TAR_OPTION -cf"
            else
                TAR_CMD="tar -cf"
            fi

            if $TAR_CMD "$BACKUP_ARCHIVE" -C "$PROJECT_ROOT" .; then
                echo "Complete backup created: $BACKUP_ARCHIVE"
            else
                echo "ERROR: Failed to create backup archive"
                exit 1
            fi
            echo
            echo "Backup complete. Now proceeding with junk file deletion..."
            echo
        fi

        # Run prune analysis (and deletion if requested)
        do_prune "$PROJECT_ROOT" "${VERBOSE_FLAG:-false}" "$TYPE" "$delete_mode"

        # Show stats after backup completion if backup was created
        if [[ "$BAK_FLAG" == "true" && "$CONFIG_FOUND" == "true" ]]; then
            echo
            if [[ -n "$CONTEXT_BASE_DIR" ]]; then
                MIRROR_DIR="$CONTEXT_BASE_DIR/$PROJECT_NAME"
            else
                MAIN_BACKUP_DIR="$BACKUP_BASE_DIR/${PROJECT_NAME}.bak"
                MIRROR_DIR="$MAIN_BACKUP_DIR/$PROJECT_NAME"
            fi

            source "$ILMA_DIR/lib/console.sh"
            show_backup_stats "$PROJECT_ROOT" "$MIRROR_DIR"
        fi
        ;;
    config)
        show_config "$PROJECT_ROOT"
        ;;
    validate)
        source "$ILMA_DIR/lib/validate.sh"
        
        # Parse validation arguments from original args
        VALIDATION_LEVEL="basic"
        VALIDATION_PROJECT="$(pwd)"
        
        # Find validate in original args and parse what follows
        validate_found=false
        for ((i=0; i<${#ORIGINAL_ARGS[@]}; i++)); do
            if [[ "${ORIGINAL_ARGS[i]}" == "validate" ]]; then
                validate_found=true
                # Check next argument
                if [[ $((i+1)) -lt ${#ORIGINAL_ARGS[@]} ]]; then
                    next_arg="${ORIGINAL_ARGS[$((i+1))]}"
                    # Check if it's a validation level (accept both smoke-test and smoketest)
                    if [[ "$next_arg" =~ ^(basic|full|smoke-test|smoketest)$ ]]; then
                        # Normalize smoketest to smoke-test
                        if [[ "$next_arg" == "smoketest" ]]; then
                            next_arg="smoke-test"
                        fi
                        VALIDATION_LEVEL="$next_arg"
                        # Check for project path after level
                        if [[ $((i+2)) -lt ${#ORIGINAL_ARGS[@]} ]]; then
                            VALIDATION_PROJECT="$(realpath "${ORIGINAL_ARGS[$((i+2))]}" 2>/dev/null)" || {
                                echo "Error: Invalid project path '${ORIGINAL_ARGS[$((i+2))]}'"
                                exit 1
                            }
                        fi
                    else
                        # Next argument is project path, use default basic level
                        VALIDATION_PROJECT="$(realpath "$next_arg" 2>/dev/null)" || {
                            echo "Error: Invalid project path '$next_arg'"
                            exit 1
                        }
                    fi
                fi
                break
            fi
        done
        
        run_validation "$VALIDATION_LEVEL" "$VALIDATION_PROJECT"
        ;;
    decrypt)
        source "$ILMA_DIR/lib/gpg.sh"
        if [[ -z "$PROJECT_ROOT" ]]; then
            echo "Error: No input file specified for decryption"
            exit 1
        fi
        
        # Use PROJECT_ROOT as input file for decrypt command
        input_file="$PROJECT_ROOT"
        output_file="${input_file%.gpg}"
        
        if decrypt_file "$input_file" "$output_file"; then
            if is_archive "$output_file"; then
                extract_dir="./$(basename "${output_file%.*}")"
                echo "Extracting to $extract_dir..."
                if extract_archive "$output_file" "$extract_dir"; then
                    echo "Decryption and extraction complete: $extract_dir"
                else
                    echo "Decryption successful, but extraction failed: $output_file"
                fi
            else
                echo "Decryption complete: $output_file"
            fi
        fi
        ;;
    extract)
        source "$ILMA_DIR/lib/compression.sh"
        if [[ -z "$PROJECT_ROOT" ]]; then
            echo "Error: No archive file specified for extraction"
            exit 1
        fi
        
        # Use PROJECT_ROOT as input archive file
        archive_file="$PROJECT_ROOT"
        
        if [[ ! -f "$archive_file" ]]; then
            echo "Error: Archive file does not exist: $archive_file"
            exit 1
        fi
        
        if ! is_archive "$archive_file"; then
            echo "Error: File is not a recognized archive: $archive_file"
            exit 1
        fi
        
        # Create safe extraction directory based on archive name
        archive_base="$(basename "$archive_file")"
        # Remove all extensions (.tar.zst -> archive_base, .tar.gz -> archive_base, etc)
        safe_dir="${archive_base%%.*}"
        
        if [[ -e "$safe_dir" ]]; then
            echo "Error: Target directory already exists: $safe_dir"
            exit 1
        fi
        
        echo "Safely extracting $archive_file to $safe_dir/"
        mkdir -p "$safe_dir"
        
        # Use compression library to determine extraction method
        compression_type=$(get_compression_type_from_file "$archive_file")
        tar_option=$(get_tar_option "$compression_type")
        
        if [[ -n "$tar_option" ]]; then
            tar $tar_option -xf "$archive_file" -C "$safe_dir"
        else
            tar -xf "$archive_file" -C "$safe_dir"
        fi
        
        if [[ $? -eq 0 ]]; then
            echo "Archive extracted successfully to: $safe_dir/"
            echo "Contents:"
            ls -la "$safe_dir/"
        else
            echo "Extraction failed"
            rmdir "$safe_dir" 2>/dev/null
            exit 1
        fi
        ;;
    *)
        echo "Error: Unknown command '$COMMAND'"
        exit 1
        ;;
esac

exit 0
