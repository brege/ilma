#!/bin/bash
set -euo pipefail

# Detect tool root from ilma location
ILMA_DIR="$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")"
TOOL_ROOT="$(dirname "$ILMA_DIR")"

# Store original arguments for commands that need special parsing
ORIGINAL_ARGS=("$@")

# Handle help and version - check for help early before any path resolution
HELP_REQUESTED=false
HELP_COMMAND=""

# Early scan for help flags and commands
for arg in "$@"; do
    if [[ "$arg" == "--help" || "$arg" == "-h" ]]; then
        HELP_REQUESTED=true
    elif [[ "$arg" =~ ^(backup|console|scan|prune|config|decrypt|extract|validate)$ ]]; then
        HELP_COMMAND="$arg"
    fi
done

# Handle main help (no subcommand specified)
if [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]] && [[ -z "$HELP_COMMAND" ]]; then
    cat <<EOF
Usage: ilma [COMMAND] [OPTIONS] [PROJECT_PATH]

COMMANDS:
  backup                               Create backup and context mirror (default)
  console                              Show project statistics
  scan                                 Scan project files and detect junk
  prune                                Dry-run analysis of files to clean (no deletion)
  config                               Show configuration details
  validate                             Validate configuration and connectivity
  decrypt                              Decrypt GPG-encrypted archive
  extract                              Safely extract archive (prevents tarbombs)

OPTIONS:
  --archive [OUTPUT_PATH]              Create compressed archive only
  --encrypt [OUTPUT_PATH]              Create encrypted archive only  
  --context [OUTPUT_PATH]              Create context mirror only
  --remote SERVER:/PATH                Sync directly to remote server
  --type TYPE                          Use project type configuration
  --pretty                             Show detailed output (for scan command)
  --verbose                            Show detailed output (for prune command)
  --bak                                Create backup then delete junk files (for prune command)
  --delete                             Delete junk files without backup (for prune command)
  --no-extract                         Decrypt only, do not extract archive (for decrypt command)
  --force                              Replace existing directories (for decrypt/extract commands)
  --outdir DIR                         Extract to specific directory (for decrypt/extract commands)
  -h, --help                           Show this help

PROJECT TYPES:
  bash, latex, node, python

EXAMPLES:
  ilma                                 Backup current directory
  ilma ~/my-project                    Backup specific project  
  ilma --type latex                    Backup, ignoring common LaTeX cruft
  ilma --archive                       Create compressed archive only
  ilma --encrypt                       Create encrypted archive only
  ilma --archive --remote srv:/backup  Archive and upload to remote server
  ilma --context ~/docs                Create context mirror only
  ilma console                         Show project statistics
  ilma scan --type python --pretty     Scan Python project with detailed output
  ilma prune --type latex --verbose    Analyze LaTeX project cruft (dry-run only)
  ilma prune --type python --bak       Backup Python project then delete junk
  ilma prune --type latex --delete     Delete LaTeX project junk (no backup)
  ilma config                          Show effective configuration
  ilma decrypt file.tar.zst.gpg        Decrypt and extract GPG-encrypted archive
  ilma extract archive.tar.zst         Safely extract archive to contained directory

CONFIGURATION:
 ● Create .ilma.conf in project root to customize behavior.
 ● See example configurations: $ILMA_DIR/configs/.
 ● Consider adding .ilma.conf to ~/.config/git/ignore.
EOF
    exit 0
fi

# Handle subcommand help early
if [[ "$HELP_REQUESTED" == "true" && -n "$HELP_COMMAND" ]]; then
    case "$HELP_COMMAND" in
        scan)
            "$ILMA_DIR/lib/scan.sh" --help
            exit 0
            ;;
        prune)
            source "$ILMA_DIR/lib/prune.sh"
            usage
            exit 0
            ;;
        console)
            source "$ILMA_DIR/lib/console.sh"
            usage
            exit 0
            ;;
        config)
            source "$ILMA_DIR/lib/config.sh"
            usage
            exit 0
            ;;
        validate)
            cat <<EOF
Usage: ilma validate [LEVEL] [PROJECT_PATH]

Validate configuration and connectivity for ilma setup.

LEVELS:
  basic       Basic configuration and path validation (default)
  full        Include remote connectivity tests  
  smoke-test  Full validation plus end-to-end test with generated dummy project

Examples:
  ilma validate                         # Basic validation of current directory
  ilma validate full /path/to/project   # Full validation of specific project  
  ilma validate smoke-test              # Complete test using temporary dummy project

Note: smoke-test creates its own temporary test project for validation.

Exit codes:
  0 - All checks passed (warnings allowed)
  1 - Validation failed with errors
EOF
            exit 0
            ;;
        backup)
            cat <<EOF
Usage: ilma backup [OPTIONS] [PROJECT_PATH]

Create backup and context mirror of a project (default command).

This is the same as running 'ilma' without any command.
For full help, run: ilma --help
EOF
            exit 0
            ;;
        extract)
            cat <<EOF
Usage: ilma extract [OPTIONS] <archive_file>

Safely extract archive to contained directory (prevents tarbombs).

Creates a directory based on the archive name and extracts contents there.
Supports all compression formats: .tar.zst, .tar.gz, .tar.bz2, .tar.xz, etc.

OPTIONS:
  --force            Replace existing target directory if it exists
  --outdir DIR       Extract to specific directory instead of auto-generated name

Examples:
  ilma extract project.tar.zst             # Extracts to project/
  ilma extract backup.tar.gz               # Extracts to backup/
  ilma extract --force project.tar.zst     # Replace existing project/ directory
  ilma extract --outdir temp backup.tar.gz # Extract to temp/ directory
EOF
            exit 0
            ;;
        decrypt)
            cat <<EOF
Usage: ilma decrypt [OPTIONS] <encrypted_file>

Decrypt a GPG-encrypted file and optionally extract if it's an archive.

OPTIONS:
  --no-extract       Decrypt only, do not extract archive
  --force            Replace existing target directory if it exists
  --outdir DIR       Extract to specific directory instead of auto-generated name

Examples:
  ilma decrypt backup.tar.zst.gpg              # Decrypt and extract to backup/
  ilma decrypt project.tar.gz.gpg             # Decrypt and extract to project/
  ilma decrypt --no-extract data.tar.gpg      # Decrypt to data.tar only
  ilma decrypt --force backup.tar.zst.gpg     # Replace existing backup/ directory
  ilma decrypt --outdir restored backup.gpg   # Extract to restored/ directory
EOF
            exit 0
            ;;
    esac
fi

# Parse arguments to determine command and options
COMMAND=""
TYPE=""
ARCHIVE_FLAG=""
ENCRYPT_FLAG=""
CONTEXT_FLAG=""
REMOTE_FLAG=""
CONFIG_FLAG=""
PROJECT_ROOT=""
VERBOSE_FLAG=""
PRETTY_FLAG=""
BAK_FLAG=""
DELETE_FLAG=""
NO_EXTRACT_FLAG=""
FORCE_FLAG=""
OUTDIR_FLAG=""

# First pass - scan all arguments to identify command
COMMAND="backup"  # Default command
for arg in "$@"; do
    case "$arg" in
        backup|console|scan|prune|config|decrypt|extract|validate)
            COMMAND="$arg"
            break
            ;;
        --config)
            COMMAND="config"
            break
            ;;
    esac
done

# Second pass - parse remaining arguments
while (( $# > 0 )); do
    case "$1" in
        backup|console|scan|prune|config|decrypt|extract|validate)
            # Skip command names (already detected in first pass)
            shift
            ;;
        --archive)
            ARCHIVE_FLAG="true"
            # Check if next argument is explicitly an output path (ends with archive extension)
            if [[ -n "${2:-}" && "${2:0:1}" != "-" && "${2}" =~ \.(tar\.|tgz|tbz2|txz).*$ ]]; then
                ARCHIVE_FLAG="$2"
                shift 2
            else
                shift
            fi
            ;;
        --encrypt)
            ENCRYPT_FLAG="true"
            # Check if next argument is explicitly an output path (ends with archive extension or .gpg)
            if [[ -n "${2:-}" && "${2:0:1}" != "-" && ( "${2}" =~ \.(tar\.|tgz|tbz2|txz).*$ || "${2}" =~ \.gpg$ ) ]]; then
                ENCRYPT_FLAG="$2"
                shift 2
            else
                shift
            fi
            ;;
        --context)
            CONTEXT_FLAG="true"
            # Check if next argument is explicitly an output path (contains / or doesn't look like a directory name)
            if [[ -n "${2:-}" && "${2:0:1}" != "-" && "${2}" =~ "/" ]]; then
                CONTEXT_FLAG="$2"
                shift 2
            else
                shift
            fi
            ;;
        --remote)
            if [[ -z "${2:-}" ]]; then
                echo "Error: --remote requires SERVER:/PATH argument" >&2
                exit 1
            fi
            REMOTE_FLAG="$2"
            shift 2
            ;;
        --config)
            CONFIG_FLAG="true"
            shift
            ;;
        --type)
            if [[ -z "${2:-}" ]]; then
                echo "Error: --type requires an argument" >&2
                exit 1
            fi
            TYPE="$2"
            shift 2
            ;;
        --verbose)
            VERBOSE_FLAG="true"
            shift
            ;;
        --pretty)
            PRETTY_FLAG="true"
            shift
            ;;
        --bak)
            BAK_FLAG="true"
            shift
            ;;
        --delete)
            DELETE_FLAG="true"
            shift
            ;;
        --no-extract)
            NO_EXTRACT_FLAG="true"
            shift
            ;;
        --force)
            FORCE_FLAG="true"
            shift
            ;;
        --outdir)
            if [[ -z "${2:-}" ]]; then
                echo "Error: --outdir requires a directory path" >&2
                exit 1
            fi
            OUTDIR_FLAG="$2"
            shift 2
            ;;
        backup|console|scan|prune|config|decrypt|extract)
            # Skip command names
            shift
            ;;
        --help|-h)
            # Skip help flags (handled earlier)
            shift
            ;;
        *)
            if [[ -z "$PROJECT_ROOT" ]]; then
                PROJECT_ROOT="$(realpath "$1" 2>/dev/null)" || { echo "Error: Invalid path '$1'"; exit 1; }
            fi
            shift
            ;;
    esac
done

# Set default project root if not specified
if [[ -z "$PROJECT_ROOT" ]]; then
    PROJECT_ROOT="$(pwd)"
fi

# Validate project directory (except for decrypt/extract/validate commands which handle their own validation)
if [[ "$COMMAND" != "decrypt" && "$COMMAND" != "extract" && "$COMMAND" != "validate" ]]; then
    if [[ ! -d "$PROJECT_ROOT" ]]; then
        echo "Error: Directory does not exist: $PROJECT_ROOT"
        exit 1
    fi
fi

PROJECT_NAME="$(basename "$PROJECT_ROOT")"

# Load configuration and compression library
source "$ILMA_DIR/lib/config.sh"
source "$ILMA_DIR/lib/compression.sh"
load_config "$PROJECT_ROOT" "$TYPE"

# Handle --config command early (before special modes)
if [[ "$CONFIG_FLAG" == "true" || "$COMMAND" == "config" ]]; then
    show_config "$PROJECT_ROOT"
    exit 0
fi

# Dispatch to appropriate command
case "$COMMAND" in
    backup)
        # Load config for all backup modes
        source "$ILMA_DIR/lib/config.sh"
        load_config "$PROJECT_ROOT" "$TYPE"
        
        # Handle specialized backup modes
        if [[ ( "$ARCHIVE_FLAG" == "true" || -n "$ARCHIVE_FLAG" ) && ( "$ENCRYPT_FLAG" == "true" || -n "$ENCRYPT_FLAG" ) ]]; then
            # Combined archive + encrypt mode
            source "$ILMA_DIR/lib/backup/encrypt.sh"
            output_path="$([[ "$ENCRYPT_FLAG" == "true" ]] && echo "" || echo "$ENCRYPT_FLAG")"
            create_encrypted_archive "$PROJECT_ROOT" "$output_path"
            
            # Handle remote upload if specified
            if [[ -n "$REMOTE_FLAG" ]]; then
                source "$ILMA_DIR/lib/backup/remote.sh"
                encrypted_file="$output_path"
                [[ -z "$encrypted_file" ]] && encrypted_file="$(dirname "$PROJECT_ROOT")/$(basename "$PROJECT_ROOT")$(get_archive_extension "$COMPRESSION_TYPE").gpg"
                sync_archive_to_remote "$encrypted_file" "$REMOTE_FLAG"
            fi
            
        elif [[ "$ARCHIVE_FLAG" == "true" || -n "$ARCHIVE_FLAG" ]]; then
            # Archive-only mode
            source "$ILMA_DIR/lib/backup/archive.sh"
            output_path="$([[ "$ARCHIVE_FLAG" == "true" ]] && echo "" || echo "$ARCHIVE_FLAG")"
            create_archive_only "$PROJECT_ROOT" "$output_path"
            
            # Handle remote upload if specified
            if [[ -n "$REMOTE_FLAG" ]]; then
                source "$ILMA_DIR/lib/backup/remote.sh"
                archive_file="$output_path"
                [[ -z "$archive_file" ]] && archive_file="$(dirname "$PROJECT_ROOT")/$(basename "$PROJECT_ROOT")$(get_archive_extension "$COMPRESSION_TYPE")"
                sync_archive_to_remote "$archive_file" "$REMOTE_FLAG"
            fi
            
        elif [[ "$ENCRYPT_FLAG" == "true" || -n "$ENCRYPT_FLAG" ]]; then
            # Encrypt-only mode
            source "$ILMA_DIR/lib/backup/encrypt.sh"
            output_path="$([[ "$ENCRYPT_FLAG" == "true" ]] && echo "" || echo "$ENCRYPT_FLAG")"
            create_encrypted_archive "$PROJECT_ROOT" "$output_path"
            
            # Handle remote upload if specified
            if [[ -n "$REMOTE_FLAG" ]]; then
                source "$ILMA_DIR/lib/backup/remote.sh"
                encrypted_file="$output_path"
                [[ -z "$encrypted_file" ]] && encrypted_file="$(dirname "$PROJECT_ROOT")/$(basename "$PROJECT_ROOT")$(get_archive_extension "$COMPRESSION_TYPE").gpg"
                sync_archive_to_remote "$encrypted_file" "$REMOTE_FLAG"
            fi
            
        elif [[ "$CONTEXT_FLAG" == "true" || -n "$CONTEXT_FLAG" ]]; then
            # Context-only mode
            source "$ILMA_DIR/lib/backup/context.sh"
            output_path="$([[ "$CONTEXT_FLAG" == "true" ]] && echo "" || echo "$CONTEXT_FLAG")"
            create_context_only "$PROJECT_ROOT" "$output_path"
            
        elif [[ -n "$REMOTE_FLAG" ]]; then
            # Direct remote sync mode
            source "$ILMA_DIR/lib/backup/remote.sh"
            sync_to_remote "$PROJECT_ROOT" "$REMOTE_FLAG"
            
        else
            # Standard backup mode
            source "$ILMA_DIR/lib/backup.sh"
            do_backup "$PROJECT_ROOT"

            # Show stats after backup completion
            if [[ "$CONFIG_FOUND" == "true" ]]; then
                # Set mirror directory path for stats
                if [[ -n "$CONTEXT_BASE_DIR" ]]; then
                    MIRROR_DIR="$CONTEXT_BASE_DIR/$PROJECT_NAME"
                else
                    MAIN_BACKUP_DIR="$BACKUP_BASE_DIR/${PROJECT_NAME}.bak"
                    MIRROR_DIR="$MAIN_BACKUP_DIR/$PROJECT_NAME"
                fi

                source "$ILMA_DIR/lib/console.sh"
                show_backup_stats "$PROJECT_ROOT" "$MIRROR_DIR"
            fi
        fi
        ;;
    console)
        source "$ILMA_DIR/lib/console.sh"
        show_console_summary "$PROJECT_ROOT"
        ;;
    scan)
        # Load config without special mode handling for scan
        source "$ILMA_DIR/lib/config.sh"
        load_config "$PROJECT_ROOT" "$TYPE"

        # Build arguments for scan.sh
        scan_args=()
        [[ -n "$TYPE" ]] && scan_args+=(--type "$TYPE")
        [[ "$PRETTY_FLAG" == "true" ]] && scan_args+=(--pretty)
        scan_args+=("$PROJECT_ROOT")

        # Call scan.sh directly
        "$ILMA_DIR/lib/scan.sh" "${scan_args[@]}"
        ;;
    prune)
        # Load config
        source "$ILMA_DIR/lib/config.sh"
        load_config "$PROJECT_ROOT" "$TYPE"
        # Only call handle_special_modes if backup is needed (for --bak flag)
        if [[ "$BAK_FLAG" == "true" ]]; then
            handle_special_modes "" "$PROJECT_ROOT"
        fi
        source "$ILMA_DIR/lib/prune.sh"

        # Determine if we're in delete mode
        delete_mode="false"
        if [[ "$BAK_FLAG" == "true" || "$DELETE_FLAG" == "true" ]]; then
            delete_mode="true"
        fi

        # If --bak flag is set, create complete backup first
        if [[ "$BAK_FLAG" == "true" ]]; then
            echo "Creating complete backup before deletion..."
            PROJECT_NAME="$(basename "$PROJECT_ROOT")"
            PARENT_DIR="$(dirname "$PROJECT_ROOT")"
            TIMESTAMP="$(date '+%Y%m%d-%H%M%S')"
            # Get archive extension based on compression type
            ARCHIVE_EXT=$(get_archive_extension "$COMPRESSION_TYPE")
            BACKUP_ARCHIVE="$PARENT_DIR/${PROJECT_NAME}.orig${ARCHIVE_EXT}"

            # Get tar option for compression
            TAR_OPTION=$(get_tar_option "$COMPRESSION_TYPE")
            if [[ -n "$TAR_OPTION" ]]; then
                TAR_CMD="tar $TAR_OPTION -cf"
            else
                TAR_CMD="tar -cf"
            fi

            if $TAR_CMD "$BACKUP_ARCHIVE" -C "$PROJECT_ROOT" .; then
                echo "Complete backup created: $BACKUP_ARCHIVE"
            else
                echo "ERROR: Failed to create backup archive"
                exit 1
            fi
            echo
            echo "Backup complete. Now proceeding with junk file deletion..."
            echo
        fi

        # Run prune analysis (and deletion if requested)
        do_prune "$PROJECT_ROOT" "${VERBOSE_FLAG:-false}" "$TYPE" "$delete_mode"

        # Show stats after backup completion if backup was created
        if [[ "$BAK_FLAG" == "true" && "$CONFIG_FOUND" == "true" ]]; then
            echo
            if [[ -n "$CONTEXT_BASE_DIR" ]]; then
                MIRROR_DIR="$CONTEXT_BASE_DIR/$PROJECT_NAME"
            else
                MAIN_BACKUP_DIR="$BACKUP_BASE_DIR/${PROJECT_NAME}.bak"
                MIRROR_DIR="$MAIN_BACKUP_DIR/$PROJECT_NAME"
            fi

            source "$ILMA_DIR/lib/console.sh"
            show_backup_stats "$PROJECT_ROOT" "$MIRROR_DIR"
        fi
        ;;
    config)
        show_config "$PROJECT_ROOT"
        ;;
    validate)
        source "$ILMA_DIR/lib/validate.sh"
        
        # Parse validation arguments from original args
        VALIDATION_LEVEL="basic"
        VALIDATION_PROJECT="$(pwd)"
        
        # Find validate in original args and parse what follows
        validate_found=false
        for ((i=0; i<${#ORIGINAL_ARGS[@]}; i++)); do
            if [[ "${ORIGINAL_ARGS[i]}" == "validate" ]]; then
                validate_found=true
                # Check next argument
                if [[ $((i+1)) -lt ${#ORIGINAL_ARGS[@]} ]]; then
                    next_arg="${ORIGINAL_ARGS[$((i+1))]}"
                    # Check if it's a validation level (accept both smoke-test and smoketest)
                    if [[ "$next_arg" =~ ^(basic|full|smoke-test|smoketest)$ ]]; then
                        # Normalize smoketest to smoke-test
                        if [[ "$next_arg" == "smoketest" ]]; then
                            next_arg="smoke-test"
                        fi
                        VALIDATION_LEVEL="$next_arg"
                        # Check for project path after level
                        if [[ $((i+2)) -lt ${#ORIGINAL_ARGS[@]} ]]; then
                            VALIDATION_PROJECT="$(realpath "${ORIGINAL_ARGS[$((i+2))]}" 2>/dev/null)" || {
                                echo "Error: Invalid project path '${ORIGINAL_ARGS[$((i+2))]}'"
                                exit 1
                            }
                        fi
                    else
                        # Next argument is project path, use default basic level
                        VALIDATION_PROJECT="$(realpath "$next_arg" 2>/dev/null)" || {
                            echo "Error: Invalid project path '$next_arg'"
                            exit 1
                        }
                    fi
                fi
                break
            fi
        done
        
        run_validation "$VALIDATION_LEVEL" "$VALIDATION_PROJECT"
        ;;
    decrypt)
        source "$ILMA_DIR/lib/decrypt.sh"
        do_decrypt "$PROJECT_ROOT" "$NO_EXTRACT_FLAG" "$FORCE_FLAG" "$OUTDIR_FLAG"
        ;;
    extract)
        source "$ILMA_DIR/lib/decrypt.sh"
        do_extract "$PROJECT_ROOT" "$FORCE_FLAG" "$OUTDIR_FLAG"
        ;;
    *)
        echo "Error: Unknown command '$COMMAND'"
        exit 1
        ;;
esac

exit 0
