#!/bin/bash
set -euo pipefail

# Detect tool root from ilma location  
ILMA_DIR="$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")"
TOOL_ROOT="$(dirname "$ILMA_DIR")"

# Handle help and version
if [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]]; then
    echo "Usage: ilma [OPTIONS] [PROJECT_PATH]"
    echo ""
    echo "Options:"
    echo "  --archive PROJECT_PATH ARCHIVE_PATH  Create archive at specific location"
    echo "  --config                             Show resolved configuration paths"
    echo "  -c, --console                        Show stats only (no backup)"
    echo "  -h, --help                           Show this help"
    echo ""
    echo "Examples:"
    echo "  ilma                                 Backup current directory"
    echo "  ilma ~/build/project                 Backup specific project"
    echo "  ilma --archive project archive/      Archive project to archive/"
    echo "  ilma -c                              Show stats for current directory"
    echo "  ilma --config                        Show effective configuration"
    echo ""
    echo "Configuration:"
    echo " ● Create .ilma.conf in project root to customize behavior."
    echo " ● See example configurations: $ILMA_DIR/examples/."
    echo " ● Consider adding .ilma.conf to ~/.config/git/ignore."
    exit 0
fi

# Parse arguments
ARCHIVE_FLAG=""
CONFIG_FLAG=""
if [[ "${1:-}" == "--archive" && -n "${2:-}" && -n "${3:-}" ]]; then
    # --archive project_path archive_path
    PROJECT_ROOT="$(realpath "$2" 2>/dev/null)" || { echo "Error: Invalid project path '$2'"; exit 1; }
    ARCHIVE_FLAG="$3"
    shift 3
elif [[ "${1:-}" == "--config" ]]; then
    CONFIG_FLAG="true"
    if [[ -n "${2:-}" ]]; then
        PROJECT_ROOT="$(realpath "$2" 2>/dev/null)" || { echo "Error: Invalid path '$2'"; exit 1; }
        shift 2
    else
        PROJECT_ROOT="$(pwd)"
        shift
    fi
elif [[ "${1:-}" != "-c" && "${1:-}" != "--console" && -n "${1:-}" ]]; then
    PROJECT_ROOT="$(realpath "$1" 2>/dev/null)" || { echo "Error: Invalid path '$1'"; exit 1; }
    shift
else
    PROJECT_ROOT="$(pwd)"
fi

PROJECT_NAME="$(basename "$PROJECT_ROOT")"

# =============================================================================
# DEFAULT CONFIGURATION - Can be overridden by config files
# =============================================================================

# Backup locations
BACKUP_BASE_DIR="$TOOL_ROOT"                # Working backup location
ARCHIVE_BASE_DIR=""                         # Compressed archive location (empty = disabled)
CONTEXT_BASE_DIR=""                         # Context mirror location (empty = nested in backup)
CREATE_COMPRESSED_ARCHIVE=false             # Create timestamped .tar.zst archives
MAX_ARCHIVES=1                              # Max number of compressed archives to keep

# XDG directories backup
BACKUP_XDG_DIRS=false                       # Backup user config/data directories
XDG_PATHS=("~/.config" "~/.local/share" "~/.cache")

# File extensions to track in stats
EXTENSIONS=(md txt)

# Rsync exclusion patterns - minimal defaults
RSYNC_EXCLUDES=(
    --exclude '.git/'
    --exclude '.gitignore'
    --exclude '.archive.conf'
    --exclude '.ilma.conf'
    --exclude '.backup.conf'
)

# Optional context files to copy (if they exist)
CONTEXT_FILES=()

# Tree command exclusions for TREE.txt generation
TREE_EXCLUDES=".git|.archive.conf|.ilma.conf|.backup.conf"

# =============================================================================
# LOAD PROJECT CONFIGURATION
# =============================================================================

# Load configuration file if present (first match wins)
CONFIG_FOUND=false
for config_file in ".ilma.conf" ".archive.conf" ".backup.conf"; do
    if [[ -f "$PROJECT_ROOT/$config_file" ]]; then
        source "$PROJECT_ROOT/$config_file"
        CONFIG_FOUND=true
        break
    fi
done

# Handle --archive flag or fallback mode
if [[ -n "$ARCHIVE_FLAG" ]]; then
    # --archive mode: force archive creation
    RSYNC_EXCLUDES=()  # No exclusions - archive everything
    CREATE_COMPRESSED_ARCHIVE=true
    ARCHIVE_BASE_DIR="$(dirname "$ARCHIVE_FLAG")"
    BACKUP_XDG_DIRS=false
    CONTEXT_BASE_DIR=""  # No context mirror
    CONFIG_FOUND="false"  # Skip normal workflow
    echo "Archive mode: creating complete image at $ARCHIVE_FLAG"
elif [[ "$CONFIG_FOUND" == "false" ]]; then
    # Fallback mode: if no config found, create simple archive with no exclusions
    RSYNC_EXCLUDES=()  # No exclusions - archive everything
    CREATE_COMPRESSED_ARCHIVE=true
    ARCHIVE_BASE_DIR="."  # Current directory
    BACKUP_XDG_DIRS=false
    CONTEXT_BASE_DIR=""  # No context mirror in fallback mode
    
    echo "No configuration found - using fallback archive mode (no exclusions)"
fi

# Handle --config flag
if [[ "$CONFIG_FLAG" == "true" ]]; then
    echo "Project: $PROJECT_ROOT"
    echo "Config found: ${CONFIG_FOUND}"
    echo
    if [[ "$CONFIG_FOUND" == "true" ]]; then
        echo "Resolved paths:"
        echo "  BACKUP_BASE_DIR   = $(realpath "${BACKUP_BASE_DIR/#\~/$HOME}")"
        if [[ -n "$ARCHIVE_BASE_DIR" ]]; then
            echo "  ARCHIVE_BASE_DIR  = $(realpath "${ARCHIVE_BASE_DIR/#\~/$HOME}")"
        else
            echo "  ARCHIVE_BASE_DIR  = (not set)"
        fi
        if [[ -n "$CONTEXT_BASE_DIR" ]]; then
            echo "  CONTEXT_BASE_DIR  = $(realpath "${CONTEXT_BASE_DIR/#\~/$HOME}")"
        else
            echo "  CONTEXT_BASE_DIR  = (nested in backup)"
        fi
        echo
        echo "Settings:"
        echo "  CREATE_COMPRESSED_ARCHIVE = $CREATE_COMPRESSED_ARCHIVE"
        echo "  MAX_ARCHIVES             = $MAX_ARCHIVES"
        echo "  BACKUP_XDG_DIRS          = $BACKUP_XDG_DIRS"
        echo "  EXTENSIONS               = (${EXTENSIONS[*]})"
    else
        echo "Fallback mode - no configuration file found."
        echo "  ARCHIVE_BASE_DIR = $(realpath "${ARCHIVE_BASE_DIR/#\~/$HOME}")"
    fi
    exit 0
fi

# =============================================================================
# MAIN LOGIC
# =============================================================================

# --- Console-only flag: -c or --console (show stats only, no backup/mirror) ---
if [[ "${1:-}" == "-c" || "${1:-}" == "--console" ]]; then
  # Only show stats if we have a config file (otherwise no mirror to analyze)
  if [[ "$CONFIG_FOUND" == "false" ]]; then
      echo "No configuration found - fallback mode has no stats to display"
      echo "Create a .ilma.conf file to enable stats and context mirrors"
      exit 0
  fi
  
  MAIN_BACKUP_DIR="$BACKUP_BASE_DIR/${PROJECT_NAME}.bak"
  
  # Set context mirror location for console mode
  if [[ -n "$CONTEXT_BASE_DIR" ]]; then
      MIRROR_DIR="$CONTEXT_BASE_DIR/$PROJECT_NAME"
  else
      # Default: nested in backup directory
      MIRROR_DIR_BASENAME="$PROJECT_NAME"
      MIRROR_DIR="$MAIN_BACKUP_DIR/$MIRROR_DIR_BASENAME"
  fi

  SOURCE_DIR="$PROJECT_ROOT"

  source "$ILMA_DIR/lib/functions.sh"

  # --- Mirror Reduction Stats Summary ---

  declare -A files_source files_mirror lines_source lines_mirror

  for ext in "${EXTENSIONS[@]}"; do
    files_source[$ext]=$(git-count-files "$SOURCE_DIR" "*.${ext}" | awk -v e="*.${ext}:" '$1==e {print $2}')
    files_mirror[$ext]=$(git-count-files "$MIRROR_DIR" "*.${ext}" | awk -v e="*.${ext}:" '$1==e {print $2}')
    lines_source[$ext]=$(git-count-lines "$SOURCE_DIR" "*.${ext}" | awk -v e="*.${ext}:" '$1==e {print $(NF-1)}')
    lines_mirror[$ext]=$(git-count-lines "$MIRROR_DIR" "*.${ext}" | awk -v e="*.${ext}:" '$1==e {print $(NF-1)}')
    files_source[$ext]=${files_source[$ext]:-0}
    files_mirror[$ext]=${files_mirror[$ext]:-0}
    lines_source[$ext]=${lines_source[$ext]:-0}
    lines_mirror[$ext]=${lines_mirror[$ext]:-0}
  done

  total_files() {
    git-count-files "$1" | awk '{sum+=$2} END {print sum}'
  }
  total_lines() {
    git-count-lines "$1" | awk '/files/ {sum+=$(NF-1)} END {print sum}'
  }
  total_size() {
    du -sm "$1" | awk '{print $1}'
  }

  total_files_source=$(total_files "$SOURCE_DIR")
  total_files_mirror=$(total_files "$MIRROR_DIR")
  delta_files=$((total_files_source - total_files_mirror))

  total_lines_source=$(total_lines "$SOURCE_DIR")
  total_lines_mirror=$(total_lines "$MIRROR_DIR")
  delta_lines=$((total_lines_source - total_lines_mirror))

  size_source=$(total_size "$SOURCE_DIR")
  size_mirror=$(total_size "$MIRROR_DIR")
  delta_size=$((size_source - size_mirror))

  percent() {
    local orig="$1"
    local new="$2"
    local pct
    if [[ "$orig" -eq 0 ]]; then
      pct="N/A"
    else
      pct=$(awk "BEGIN {printf \"%.1f%%\", ($orig-$new)*100/$orig}")
    fi

    local pad="        "
    local padded="${pad}${pct}"
    padded="${padded: -8}"

    local color_reset="\033[0m"
    local color=""
    if [[ "$pct" =~ ^[0-9]+(\.[0-9]+)?%$ ]]; then
      local val="${pct%\%}"
      if (( $(echo "$val > 50" | bc -l) )); then
        color="\033[1;32m"
      elif (( $(echo "$val > 25" | bc -l) )); then
        color="\033[1;33m"
      fi
      printf "%b%s%b" "$color" "$padded" "$color_reset"
    else
      printf "%s" "$padded"
    fi
  }

  echo
  echo "Mirror Reduction Stats"
  echo "----------------------"
  printf "%-18s %10s %10s %10s %8b\n" "Metric" "Source" "Mirror" "Delta" "Reduction"
  printf "%-18s %10s %10s %10s %8s\n" "-----"  "------" "------" "-----" "--------"

  printf "%-18s %10s %10s %10s %8b\n" "Total files" "$total_files_source" "$total_files_mirror" "$delta_files" "$(percent "$total_files_source" "$total_files_mirror")"
  for ext in "${EXTENSIONS[@]}"; do
    delta=$((files_source[$ext] - files_mirror[$ext]))
    printf "%-18s %10s %10s %10s %8b\n" ".${ext} files" "${files_source[$ext]}" "${files_mirror[$ext]}" "$delta" "$(percent "${files_source[$ext]}" "${files_mirror[$ext]}")"
  done

  printf "%-18s %10s %10s %10s %8b\n" "Total lines" "$total_lines_source" "$total_lines_mirror" "$delta_lines" "$(percent "$total_lines_source" "$total_lines_mirror")"
  for ext in "${EXTENSIONS[@]}"; do
    delta=$((lines_source[$ext] - lines_mirror[$ext]))
    printf "%-18s %10s %10s %10s %8b\n" ".${ext} lines" "${lines_source[$ext]}" "${lines_mirror[$ext]}" "$delta" "$(percent "${lines_source[$ext]}" "${lines_mirror[$ext]}")"
  done

  printf "%-18s %10s %10s %10s %8b\n" "Total size (MB)" "$size_source" "$size_mirror" "$delta_size" "$(percent "$size_source" "$size_mirror")"

  echo "----------------------"

  mirror_chars=$(find "$MIRROR_DIR" -type f -exec cat {} + | wc -c)
  token_estimate=$((mirror_chars / 4))
  printf "Mirror token estimate: %s (~4 chars per token)\n" "$token_estimate"

  commit_count=$(git -C "$SOURCE_DIR" rev-list --count HEAD 2>/dev/null || echo "N/A")
  git_log=$(git -C "$SOURCE_DIR" log -1 --format='%cd|%h|%s' --date=format:'%Y-%m-%d:%H:%M' 2>/dev/null)
  if [[ -n "$git_log" ]]; then
    IFS='|' read -r commit_date commit_hash commit_msg <<< "$git_log"
    maxlen=40
    if (( ${#commit_msg} > maxlen )); then
      commit_msg="${commit_msg:0:maxlen}.."
    fi
    latest_commit="$commit_date $commit_hash $commit_msg"
  else
    latest_commit="N/A"
  fi

  printf "git: [ commits: %s ][ latest: %s ]\n" "$commit_count" "$latest_commit"
  echo "tip: git-count-{lines,files} \${SOURCE,MIRROR}_DIR   [ *.js, *.md ]  (stats for nerds)"
  echo "     ilma -c, --console (this console)"
  exit 0
fi

# --- Configuration ---
MAIN_BACKUP_DIR="$BACKUP_BASE_DIR/${PROJECT_NAME}.bak"

# Set context mirror location
if [[ -n "$CONTEXT_BASE_DIR" ]]; then
    MIRROR_DIR="$CONTEXT_BASE_DIR/$PROJECT_NAME"
    MIRROR_DIR_BASENAME="$PROJECT_NAME"  # Still need this for exclusions
else
    # Default: nested in backup directory
    MIRROR_DIR_BASENAME="$PROJECT_NAME"
    MIRROR_DIR="$MAIN_BACKUP_DIR/$MIRROR_DIR_BASENAME"
fi

# Skip backup and context steps in fallback mode
if [[ "$CONFIG_FOUND" == "true" ]]; then
    # --- Step 1: Main Full Backup ---
    echo "Step 1: Creating main full backup at '$MAIN_BACKUP_DIR'..."
    mkdir -p "$MAIN_BACKUP_DIR"
    rsync -av --delete \
         --exclude "$MIRROR_DIR_BASENAME/" \
         "$PROJECT_ROOT/" "$MAIN_BACKUP_DIR/"
    echo "Main backup complete."
fi

# Only do XDG backup, context mirror, and stats in configured mode
if [[ "$CONFIG_FOUND" == "true" ]]; then
    # --- Step 1a: Backup XDG directories if enabled ---
    if [[ "$BACKUP_XDG_DIRS" == "true" ]]; then
        echo "Step 1a: Backing up XDG directories..."
        XDG_BACKUP_DIR="$MAIN_BACKUP_DIR/xdg"
        mkdir -p "$XDG_BACKUP_DIR"
        
        for xdg_base in "${XDG_PATHS[@]}"; do
            # Expand tilde and check if project-specific directory exists
            xdg_expanded="${xdg_base/#\~/$HOME}"
            project_xdg_dir="$xdg_expanded/$PROJECT_NAME"
            
            if [[ -d "$project_xdg_dir" ]]; then
                # Create relative path structure in backup
                xdg_rel_path="${xdg_base#~/}"  # Remove ~/ prefix
                backup_dest="$XDG_BACKUP_DIR/$xdg_rel_path"
                mkdir -p "$backup_dest"
                
                rsync -av "$project_xdg_dir/" "$backup_dest/$PROJECT_NAME/"
                echo "  - Backed up $project_xdg_dir"
            fi
        done
        echo "XDG backup complete."
    fi

    echo

    # --- Step 2: Create Context Mirror ---
    echo "Step 2: Creating context mirror at '$MIRROR_DIR'..."
    mkdir -p "$MIRROR_DIR"

    # Add dynamic exclusions to the configured list
    DYNAMIC_EXCLUDES=(
        --exclude "$(basename "$MAIN_BACKUP_DIR")/"
    )

    # If using separate context directory, exclude it from backup
    if [[ -n "$CONTEXT_BASE_DIR" && "$CONTEXT_BASE_DIR" != "$BACKUP_BASE_DIR" ]]; then
        CONTEXT_BASE_BASENAME="$(basename "$CONTEXT_BASE_DIR")"
        if [[ "$PROJECT_ROOT" == *"/$CONTEXT_BASE_BASENAME"* || "$PROJECT_ROOT" == *"$CONTEXT_BASE_BASENAME" ]]; then
            DYNAMIC_EXCLUDES+=(--exclude "$(basename "$CONTEXT_BASE_DIR")/")
        fi
    fi

    FINAL_EXCLUDES=("${RSYNC_EXCLUDES[@]}" "${DYNAMIC_EXCLUDES[@]}")

    rsync -av --delete \
        "${FINAL_EXCLUDES[@]}" \
        "$PROJECT_ROOT/" "$MIRROR_DIR/"
    echo "Context mirror created."
    echo

    # --- Step 3: Generate TREE.txt and Copy Context Files into the Mirror ---
    TREE_OUT="$MIRROR_DIR/TREE.txt"
    echo "Step 3: Generating project tree and copying context files..."

    # Gather datestamp and latest commit info
    TREE_DATE="$(date -u +"%Y-%m-%d %H:%M UTC")"
    GIT_LOG=$(git -C "$PROJECT_ROOT" log -1 --format='%cd|%h|%an|%s' --date=format:'%Y-%m-%d %H:%M')
    if [[ -n "$GIT_LOG" ]]; then
      IFS='|' read -r commit_date commit_hash commit_author commit_msg <<< "$GIT_LOG"
      # Truncate commit message to 60 chars for clarity
      maxlen=60
      if (( ${#commit_msg} > maxlen )); then
        commit_msg="${commit_msg:0:maxlen}.."
      fi
      LATEST_COMMIT="Latest commit: $commit_date ($commit_hash) by $commit_author
        $commit_msg"
    else
      LATEST_COMMIT="Latest commit: N/A"
    fi

    cat > "$TREE_OUT" <<EOL
# TREE.txt snapshot for Context Mirror
# Date generated: $TREE_DATE
# $LATEST_COMMIT

~/build/
├── $PROJECT_NAME/
│   └── ... (The user's actual, complete project workspace)
│
└── ${PROJECT_NAME}.bak/
    ├── ... (A complete, 1:1 backup of the working directory)
    │
    └── $PROJECT_NAME/      <-- The nested, self-contained "Context Mirror" for LLM upload.
        ├── ... (The context project tree)
        │
        └── TREE.txt          Context file placed at the root of the mirror.
---
EOL

    tree -a -I "${TREE_EXCLUDES}|${PROJECT_NAME}.bak" "$PROJECT_ROOT" | sed "s|$PROJECT_ROOT|.|" >> "$TREE_OUT"
    echo "  - Project tree generated."

    # Copy context files if they exist
    for context_file in "${CONTEXT_FILES[@]}"; do
      if [[ -f "$PROJECT_ROOT/$context_file" ]]; then
        cp "$PROJECT_ROOT/$context_file" "$MIRROR_DIR/"
        echo "  - Copied $(basename "$context_file")."
      fi
    done

    echo

    echo "----------------------"
    echo " ✔ Success: Context mirror is ready at: $MIRROR_DIR"
    echo "----------------------"
fi

# Only show stats in configured mode
if [[ "$CONFIG_FOUND" == "true" ]]; then
    SOURCE_DIR="$PROJECT_ROOT"

    source "$ILMA_DIR/lib/functions.sh"

    # --- Mirror Reduction Stats Summary ---

    declare -A files_source files_mirror lines_source lines_mirror

    for ext in "${EXTENSIONS[@]}"; do
      files_source[$ext]=$(git-count-files "$SOURCE_DIR" "*.${ext}" | awk -v e="*.${ext}:" '$1==e {print $2}')
      files_mirror[$ext]=$(git-count-files "$MIRROR_DIR" "*.${ext}" | awk -v e="*.${ext}:" '$1==e {print $2}')
      lines_source[$ext]=$(git-count-lines "$SOURCE_DIR" "*.${ext}" | awk -v e="*.${ext}:" '$1==e {print $(NF-1)}')
      lines_mirror[$ext]=$(git-count-lines "$MIRROR_DIR" "*.${ext}" | awk -v e="*.${ext}:" '$1==e {print $(NF-1)}')
      files_source[$ext]=${files_source[$ext]:-0}
      files_mirror[$ext]=${files_mirror[$ext]:-0}
      lines_source[$ext]=${lines_source[$ext]:-0}
      lines_mirror[$ext]=${lines_mirror[$ext]:-0}
    done

    total_files() {
      git-count-files "$1" | awk '{sum+=$2} END {print sum}'
    }
    total_lines() {
      git-count-lines "$1" | awk '/files/ {sum+=$(NF-1)} END {print sum}'
    }
    total_size() {
      du -sm "$1" | awk '{print $1}'
    }

    total_files_source=$(total_files "$SOURCE_DIR")
    total_files_mirror=$(total_files "$MIRROR_DIR")
    delta_files=$((total_files_source - total_files_mirror))

    total_lines_source=$(total_lines "$SOURCE_DIR")
    total_lines_mirror=$(total_lines "$MIRROR_DIR")
    delta_lines=$((total_lines_source - total_lines_mirror))

    size_source=$(total_size "$SOURCE_DIR")
    size_mirror=$(total_size "$MIRROR_DIR")
    delta_size=$((size_source - size_mirror))

    percent() {
      local orig="$1"
      local new="$2"
      local pct
      if [[ "$orig" -eq 0 ]]; then
        pct="N/A"
      else
        pct=$(awk "BEGIN {printf \"%.1f%%\", ($orig-$new)*100/$orig}")
      fi

      local pad="        "
      local padded="${pad}${pct}"
      padded="${padded: -8}"

      local color_reset="\033[0m"
      local color=""
      if [[ "$pct" =~ ^[0-9]+(\.[0-9]+)?%$ ]]; then
        local val="${pct%\%}"
        if (( $(echo "$val > 50" | bc -l) )); then
          color="\033[1;32m"
        elif (( $(echo "$val > 25" | bc -l) )); then
        color="\033[1;33m"
        fi
        printf "%b%s%b" "$color" "$padded" "$color_reset"
      else
        printf "%s" "$padded"
      fi
    }

    echo
    echo "Mirror Reduction Stats"
    echo "----------------------"
    printf "%-18s %10s %10s %10s %8b\n" "Metric" "Source" "Mirror" "Delta" "Reduction"
    printf "%-18s %10s %10s %10s %8s\n" "-----"  "------" "------" "-----" "--------"

    printf "%-18s %10s %10s %10s %8b\n" "Total files" "$total_files_source" "$total_files_mirror" "$delta_files" "$(percent "$total_files_source" "$total_files_mirror")"
    for ext in "${EXTENSIONS[@]}"; do
      delta=$((files_source[$ext] - files_mirror[$ext]))
      printf "%-18s %10s %10s %10s %8b\n" ".${ext} files" "${files_source[$ext]}" "${files_mirror[$ext]}" "$delta" "$(percent "${files_source[$ext]}" "${files_mirror[$ext]}")"
    done

    printf "%-18s %10s %10s %10s %8b\n" "Total lines" "$total_lines_source" "$total_lines_mirror" "$delta_lines" "$(percent "$total_lines_source" "$total_lines_mirror")"
    for ext in "${EXTENSIONS[@]}"; do
      delta=$((lines_source[$ext] - lines_mirror[$ext]))
      printf "%-18s %10s %10s %10s %8b\n" ".${ext} lines" "${lines_source[$ext]}" "${lines_mirror[$ext]}" "$delta" "$(percent "${lines_source[$ext]}" "${lines_mirror[$ext]}")"
    done

    printf "%-18s %10s %10s %10s %8b\n" "Total size (MB)" "$size_source" "$size_mirror" "$delta_size" "$(percent "$size_source" "$size_mirror")"

    echo "----------------------"

    mirror_chars=$(find "$MIRROR_DIR" -type f -exec cat {} + | wc -c)
    token_estimate=$((mirror_chars / 4))
    printf "Mirror token estimate: %s (~4 chars per token)\n" "$token_estimate"

    commit_count=$(git -C "$SOURCE_DIR" rev-list --count HEAD 2>/dev/null || echo "N/A")
    git_log=$(git -C "$SOURCE_DIR" log -1 --format='%cd|%h|%s' --date=format:'%Y-%m-%d:%H:%M' 2>/dev/null)
    if [[ -n "$git_log" ]]; then
      IFS='|' read -r commit_date commit_hash commit_msg <<< "$git_log"
      maxlen=40
      if (( ${#commit_msg} > maxlen )); then
        commit_msg="${commit_msg:0:maxlen}.."
      fi
      latest_commit="$commit_date $commit_hash $commit_msg"
    else
      latest_commit="N/A"
    fi

    printf "git: [ commits: %s ][ latest: %s ]\n" "$commit_count" "$latest_commit"
    echo "tip: git-count-{lines,files} \${SOURCE,MIRROR}_DIR   [ *.js, *.md ]  (stats for nerds)"
    echo "     ilma -c, --console (this console)"
fi

# --- Step 4: Create Compressed Archive (if enabled) ---
if [[ "$CREATE_COMPRESSED_ARCHIVE" == "true" && -n "$ARCHIVE_BASE_DIR" ]]; then
    echo
    if [[ "$CONFIG_FOUND" == "true" ]]; then
        echo "Step 4: Creating compressed archive..."
    else
        echo "Creating fallback archive (complete image)..."
    fi
    
    # Set up archive directory and filename
    ARCHIVE_DIR="${ARCHIVE_BASE_DIR/#\~/$HOME}"  # Expand tilde
    mkdir -p "$ARCHIVE_DIR"
    
    TIMESTAMP=$(date +"%Y%m%d-%H%M%S")
    ARCHIVE_FILE="$ARCHIVE_DIR/${PROJECT_NAME}-${TIMESTAMP}.tar.zst"
    
    # Choose what to archive based on mode
    if [[ -n "$ARCHIVE_FLAG" ]]; then
        # --archive mode: handle directory or file target
        if [[ -d "$ARCHIVE_FLAG" ]]; then
            ARCHIVE_FILE="$ARCHIVE_FLAG/${PROJECT_NAME}-${TIMESTAMP}.tar.zst"
        else
            ARCHIVE_FILE="$ARCHIVE_FLAG"
        fi
        tar -C "$(dirname "$PROJECT_ROOT")" -cf - "$(basename "$PROJECT_ROOT")" | zstd -o "$ARCHIVE_FILE"
    elif [[ "$CONFIG_FOUND" == "false" ]]; then
        # Fallback mode: compress project directly
        tar -C "$(dirname "$PROJECT_ROOT")" -cf - "$(basename "$PROJECT_ROOT")" | zstd -o "$ARCHIVE_FILE"
    else
        # Config mode: compress the backup
        tar -C "$(dirname "$MAIN_BACKUP_DIR")" -cf - "$(basename "$MAIN_BACKUP_DIR")" | zstd -o "$ARCHIVE_FILE"
    fi
    
    if [[ -f "$ARCHIVE_FILE" ]]; then
        archive_size=$(du -sh "$ARCHIVE_FILE" | cut -f1)
        echo "  - Created archive: $ARCHIVE_FILE ($archive_size)"
        
        # Rotate old archives if MAX_ARCHIVES > 0
        if [[ "$MAX_ARCHIVES" -gt 0 ]]; then
            # List archives by modification time, newest first
            archives=($(ls -1t "$ARCHIVE_DIR"/${PROJECT_NAME}-*.tar.zst 2>/dev/null || true))
            
            if [[ ${#archives[@]} -gt $MAX_ARCHIVES ]]; then
                echo "  - Rotating archives (keeping $MAX_ARCHIVES most recent)"
                for ((i=MAX_ARCHIVES; i<${#archives[@]}; i++)); do
                    rm -f "${archives[i]}"
                    echo "    Removed: $(basename "${archives[i]}")"
                done
            fi
        fi
    else
        echo "  - Warning: Failed to create compressed archive"
    fi
fi

exit 0
